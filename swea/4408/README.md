# 4408. 자기 방으로 돌아가기

> 400개의 방에 흩어져 있는 학생들이 자신의 방에 돌아가기 위한 시간을 출력



## 내 생각

처음에 생각했던 풀이 방법은 `시작과 끝은 상관없고 큰 숫자 작은 숫자를 구분`해서 `범위를 계속해서 추가`하면서 `반복문 한번에 겹치지 않고 동시에 가는 인원을 체크하는 방법`이었다.

그런데 틀렸다..

문제는 1번방 2번방 부터 399번방 400번방까지 두개의 방이 하나의 범위(?)를 갖는 다는 것이었다.. 즉 `1~400범위가 아니라 1~200범위`라는 점이다. 시작과 끝을 2로 나눈 몫으로 (홀수는 +1) 문제풀이를 다시하였다.

또 틀렸다.. 사실 문제의 설명이 좀 부족한 감이 없지 않아 있어서 틀린 것 같은데..

코드를 고치던 중 **`다른 풀이 방법`**을 생각해냈다!

바로 한명씩 이동하면서 **`자신이 거치게 되는 1~200사이의 점들을 1씩 올려주게 되면 가장 많이 겹치는 부분이 곧 모든 학생이 다 돌아가는데 걸리는 시간`**이라고 볼 수 있는 것이다 !!!

이렇게 풀이하니 PASS!



매번 풀이할 때 다른 관점으로 보는 시도를 해야하는데 자꾸 내가 처음에 생각해낸 풀이 방법을 고집하다 오래 걸리는 나의 문제점..?을 해결해야되는데 그게 쉽지 않다.. 어서 고쳐야지



## 코드



```python
import sys
sys.stdin = open('input.txt')

T = int(input())

for tc in range(1, T+1):
    N = int(input())
    count = [0] * 201

    # 시작 부터 끝점까지 각각  count를 올린다
    # 그럼 겹치는 횟수가 각 복도에 나올 것이고
    # 이의 최대 값이 곧 걸리는 시간이 된다.
    result = 0

    for _ in range(N):
        start, end = map(int, input().split())
        
        # 1-2 같은 라인 3-4 같은 라인
        # 즉 홀수면 //2+1, 짝수면 //2
        start = start//2 + 1 if start%2 else start//2
        end = end//2 + 1 if end%2 else end//2

        if start > end:
            start, end = end, start

        for i in range(start, end+1):
            count[i] += 1
            if result < count[i]:
                result = count[i]
    

    print('#{} {}'.format(tc, result))
```

