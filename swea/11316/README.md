# 11316. 주기 찾기

> 슈도랜덤 제너레이터의 주기를 구하는 프로그램을 작성하라
>
> A0 = s
>
> Ai = (p * Ai-1 + q) mod m (i>=1)



## 내 생각

처음에는 슈도랜덤 식의 특징점이 있나 유심히 지켜보고 greedy하게 풀 수 있는 방법이 있나 생각해봤다..

그러나 규칙..? 은 찾지 못했고 한가지 사실을 파악했다. **같은 수가 나온다는 것은 그게 바로 주기의 시작이다 !** **즉, 주기 내에 같은 숫자가 여러번 나올 수가 없다..** 대충 연산의 특징만 봐도 그러한 생각을 할 수 있었다. 이전에 이미 나온 수가 현재 나왔다면 `현재 까지 오는데 걸린 count - 이전에 나왔던 count` 를 하게 되면 그 결과가 곧 주기인 것이다.

그럼 매번 수가 몇번째 나왔는지 저장하는 변수가 필요하다고 생각해서 처음에는 dictionary를 사용했다.

그러나 이렇게 쉽게 풀리면 섭섭하지.. 시간초과가 나버렸다. 문제가 뭐지 고민을 해보다가 혹시 dictionary를 사용하면 시간이 오래걸리나 라는 생각이 들었다.. 그렇담 어떻게 이 시간을 줄이면서 획기적으로 데이터를 저장할 수 있을까..?

문제를 보니 `m <= 10^6` 이라는 제한조건이 있었다. **즉, m으로 나눈 나머지 연산 이기 때문에 m보다 큰 수가 슈도랜덤 식으로 나올 수 없다!** 보통 알고리즘 문제 풀 때 10^6의 수라면 별로 큰 수는 아니다! 그렇다면 애초에 10^6크기를 가진 리스트를 초기화하고 저장하는 형태로 진행하면 어떨까 해서 시도해봤다.. (counting sort에서 사용하는 개념과 유사) 이게 답이었다.. 근데 메모리를 너무 많이 쓰는 것 같긴 한데.. 일단 정답이니 된거지..



## 코드

- 슈도랜덤식 계산을 제외한 메인코드

```python
for tc in range(1, T+1):
    s, p, q, m = map(int, input().split())
    
    # m보다 작은수만 나올 것이다
    # 메모리를 너무 많이 쓸 것 같긴한데..
    arr = [0]*m
    arr[s] = 1
    count = 1
    result = 0

    while True:
        count += 1
        # 슈도랜덤 식을 통해 다음 수가 무엇인지 확인!
        next = Pseudorandom_func(p, q, m, s)
        
        # 이미 나온 수라면 0이 아닐테니 바로 주기를 구한다.
        if arr[next]:
            result = count - arr[next]
            break

        s = next
        # 몇 번째에 해당 수가 나왔는지 저장하는 배열
        arr[s] = count

    print("#{} {}".format(tc, result))
```

